// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query.sql

package billingengine

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkDelinquentAmount = `-- name: CheckDelinquentAmount :one
SELECT loan_id, count(1) as total_week, sum(amount)
FROM billing_schedule
WHERE loan_id = $1 AND paid = false AND due_date <  now()
GROUP BY loan_id
`

type CheckDelinquentAmountRow struct {
	LoanID    int32
	TotalWeek int64
	Sum       int64
}

func (q *Queries) CheckDelinquentAmount(ctx context.Context, loanID int32) (CheckDelinquentAmountRow, error) {
	row := q.db.QueryRow(ctx, checkDelinquentAmount, loanID)
	var i CheckDelinquentAmountRow
	err := row.Scan(&i.LoanID, &i.TotalWeek, &i.Sum)
	return i, err
}

const createBillingSchedule = `-- name: CreateBillingSchedule :exec
INSERT INTO billing_schedule (loan_id, week, amount, due_date, paid)
VALUES ($1, $2, $3, $4, $5)
`

type CreateBillingScheduleParams struct {
	LoanID  int32
	Week    int32
	Amount  pgtype.Numeric
	DueDate pgtype.Date
	Paid    pgtype.Bool
}

func (q *Queries) CreateBillingSchedule(ctx context.Context, arg CreateBillingScheduleParams) error {
	_, err := q.db.Exec(ctx, createBillingSchedule,
		arg.LoanID,
		arg.Week,
		arg.Amount,
		arg.DueDate,
		arg.Paid,
	)
	return err
}

const createBillingSchedules = `-- name: CreateBillingSchedules :exec
INSERT INTO billing_schedule (loan_id, week, amount, due_date, paid)
VALUES (
    unnest($1::int[]),
    unnest($2::int[]),
    unnest($3::numeric[]),
    unnest($4::date[]),
    unnest($5::boolean[])
)
`

type CreateBillingSchedulesParams struct {
	Column1 []int32
	Column2 []int32
	Column3 []pgtype.Numeric
	Column4 []pgtype.Date
	Column5 []bool
}

func (q *Queries) CreateBillingSchedules(ctx context.Context, arg CreateBillingSchedulesParams) error {
	_, err := q.db.Exec(ctx, createBillingSchedules,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
	)
	return err
}

const createLoan = `-- name: CreateLoan :one
INSERT INTO loans (borrower_id, amount, interest_rate, duration_weeks, outstanding, delinquent_weeks, installment_amount)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id
`

type CreateLoanParams struct {
	BorrowerID        int32
	Amount            pgtype.Numeric
	InterestRate      pgtype.Numeric
	DurationWeeks     int32
	Outstanding       pgtype.Numeric
	DelinquentWeeks   int32
	InstallmentAmount pgtype.Numeric
}

func (q *Queries) CreateLoan(ctx context.Context, arg CreateLoanParams) (int32, error) {
	row := q.db.QueryRow(ctx, createLoan,
		arg.BorrowerID,
		arg.Amount,
		arg.InterestRate,
		arg.DurationWeeks,
		arg.Outstanding,
		arg.DelinquentWeeks,
		arg.InstallmentAmount,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const getBillingSchedule = `-- name: GetBillingSchedule :one
SELECT id, loan_id, week, amount, due_date, paid
FROM billing_schedule
WHERE loan_id = $1 AND paid = false ORDER BY week LIMIT 1
`

func (q *Queries) GetBillingSchedule(ctx context.Context, loanID int32) (BillingSchedule, error) {
	row := q.db.QueryRow(ctx, getBillingSchedule, loanID)
	var i BillingSchedule
	err := row.Scan(
		&i.ID,
		&i.LoanID,
		&i.Week,
		&i.Amount,
		&i.DueDate,
		&i.Paid,
	)
	return i, err
}

const getLoanByID = `-- name: GetLoanByID :one
SELECT id, amount, interest_rate, duration_weeks, outstanding, delinquent_weeks, installment_amount
FROM loans
WHERE id = $1
`

type GetLoanByIDRow struct {
	ID                int32
	Amount            pgtype.Numeric
	InterestRate      pgtype.Numeric
	DurationWeeks     int32
	Outstanding       pgtype.Numeric
	DelinquentWeeks   int32
	InstallmentAmount pgtype.Numeric
}

func (q *Queries) GetLoanByID(ctx context.Context, id int32) (GetLoanByIDRow, error) {
	row := q.db.QueryRow(ctx, getLoanByID, id)
	var i GetLoanByIDRow
	err := row.Scan(
		&i.ID,
		&i.Amount,
		&i.InterestRate,
		&i.DurationWeeks,
		&i.Outstanding,
		&i.DelinquentWeeks,
		&i.InstallmentAmount,
	)
	return i, err
}

const getLoansByBorrowerID = `-- name: GetLoansByBorrowerID :many
SELECT id, amount, interest_rate, duration_weeks, outstanding, delinquent_weeks
FROM loans
WHERE borrower_id = $1
`

type GetLoansByBorrowerIDRow struct {
	ID              int32
	Amount          pgtype.Numeric
	InterestRate    pgtype.Numeric
	DurationWeeks   int32
	Outstanding     pgtype.Numeric
	DelinquentWeeks int32
}

func (q *Queries) GetLoansByBorrowerID(ctx context.Context, borrowerID int32) ([]GetLoansByBorrowerIDRow, error) {
	rows, err := q.db.Query(ctx, getLoansByBorrowerID, borrowerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLoansByBorrowerIDRow
	for rows.Next() {
		var i GetLoansByBorrowerIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Amount,
			&i.InterestRate,
			&i.DurationWeeks,
			&i.Outstanding,
			&i.DelinquentWeeks,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLoansWithBorrower = `-- name: GetLoansWithBorrower :many
SELECT 
    loans.id AS loan_id, 
    borrowers.id AS borrower_id, 
    borrowers.name AS borrower_name, 
    loans.amount, 
    loans.interest_rate, 
    loans.duration_weeks, 
    loans.outstanding, 
    loans.delinquent_weeks,
    loans.installment_amount
FROM loans
JOIN borrowers ON loans.borrower_id = borrowers.id
LIMIT $1 OFFSET $2
`

type GetLoansWithBorrowerParams struct {
	Limit  int32
	Offset int32
}

type GetLoansWithBorrowerRow struct {
	LoanID            int32
	BorrowerID        int32
	BorrowerName      string
	Amount            pgtype.Numeric
	InterestRate      pgtype.Numeric
	DurationWeeks     int32
	Outstanding       pgtype.Numeric
	DelinquentWeeks   int32
	InstallmentAmount pgtype.Numeric
}

func (q *Queries) GetLoansWithBorrower(ctx context.Context, arg GetLoansWithBorrowerParams) ([]GetLoansWithBorrowerRow, error) {
	rows, err := q.db.Query(ctx, getLoansWithBorrower, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLoansWithBorrowerRow
	for rows.Next() {
		var i GetLoansWithBorrowerRow
		if err := rows.Scan(
			&i.LoanID,
			&i.BorrowerID,
			&i.BorrowerName,
			&i.Amount,
			&i.InterestRate,
			&i.DurationWeeks,
			&i.Outstanding,
			&i.DelinquentWeeks,
			&i.InstallmentAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBillingSchedule = `-- name: UpdateBillingSchedule :exec
UPDATE billing_schedule
SET paid = $1
WHERE loan_id = $2 AND week = $3
`

type UpdateBillingScheduleParams struct {
	Paid   pgtype.Bool
	LoanID int32
	Week   int32
}

func (q *Queries) UpdateBillingSchedule(ctx context.Context, arg UpdateBillingScheduleParams) error {
	_, err := q.db.Exec(ctx, updateBillingSchedule, arg.Paid, arg.LoanID, arg.Week)
	return err
}

const updateLoan = `-- name: UpdateLoan :exec
UPDATE loans
SET amount = $1, interest_rate = $2, duration_weeks = $3, outstanding = $4, delinquent_weeks = $5
WHERE id = $6
`

type UpdateLoanParams struct {
	Amount          pgtype.Numeric
	InterestRate    pgtype.Numeric
	DurationWeeks   int32
	Outstanding     pgtype.Numeric
	DelinquentWeeks int32
	ID              int32
}

func (q *Queries) UpdateLoan(ctx context.Context, arg UpdateLoanParams) error {
	_, err := q.db.Exec(ctx, updateLoan,
		arg.Amount,
		arg.InterestRate,
		arg.DurationWeeks,
		arg.Outstanding,
		arg.DelinquentWeeks,
		arg.ID,
	)
	return err
}

const updateRepaymentSchedule = `-- name: UpdateRepaymentSchedule :exec
UPDATE billing_schedule
SET paid = true
WHERE loan_id = $1 AND due_date < now()
`

func (q *Queries) UpdateRepaymentSchedule(ctx context.Context, loanID int32) error {
	_, err := q.db.Exec(ctx, updateRepaymentSchedule, loanID)
	return err
}
